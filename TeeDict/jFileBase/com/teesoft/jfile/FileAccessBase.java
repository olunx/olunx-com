/* * FileAccessBase.java * * Created on Jun 14, 2007, 10:23:01 AM *Copyright (C) 2007  Yong Li. All rights reserved.This library is free software; you can redistribute it and/ormodify it under the terms of the GNU Lessert General PublicLicense as published by the Free Software Foundation; eitherversion 2.1 of the License, or (at your option) any later version.This library is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNULesser General Public License for more details.You should have received a copy of the GNU Lesser General PublicLicense along with this library; if not, write to the Free SoftwareFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA */package com.teesoft.jfile;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.Vector;/** * * @author wind */public abstract class FileAccessBase extends InputStream implements FileAccess {    private String location;    public FileAccessBase(String s) {        location = s;    }    public boolean isCompressed() {        return false;    }    public boolean isRawFile() {        return true;    }        public long skip(long len) throws IOException {        long oldOffset = this.getOffset();        skipIntenal(len);        return this.getOffset() - oldOffset;    }    private long offset = 0;    public long getOffset() {        return offset;    }    protected void setOffset(long offset) {        this.offset = offset;    }    //set this to true while running in emulator will make it run faster    //but you had better make it to false while deploy. Is there are way to do this automaticly?    public static boolean geek = false;    //String platform = System.getProperty("microedition.platform");    static final int skipStep = 512;    static byte[] skipBuf = null;    protected void geekSkip(long len) throws IOException {        if (len == 0) {            return;        }        if (!geek) {            long ret = getInputStream().skip(len);            while (ret > 0 && len > 0) {                this.setOffset(this.getOffset() + ret);                len -= ret;                if (len > 0) {                    ret = getInputStream().skip(len);                }            }            if (len <= 0) {                return;            }        } else {            if (skipBuf == null) {                skipBuf = new byte[skipStep];            }            while (len > 0) {                long bytes = java.lang.Math.min(len, skipStep);                int ret = read(skipBuf, 0, (int) bytes);                if (ret == -1) {                    return;                }                setOffset(getOffset() + ret);                len -= ret;            }            //System.gc();        }    }    public void skipIntenal(long len) throws IOException {        if (isDirectory()) {            return;        }        if (len < 0) {            len = getOffset() + len;            close();            open();        }        geekSkip(len);        return;    }    public void absolute(long offset) throws IOException {        skip(offset - this.getOffset());    }    public void write(byte[] b) throws IOException {        getOutputStream().write(b);        getOutputStream().flush();    }    public void write(byte[] b, int start, int len) throws IOException {        try {            getOutputStream().write(b, start, len);        } catch (java.lang.OutOfMemoryError o) {            o.printStackTrace();        }        getOutputStream().flush();    }    public int read(byte[] b) throws IOException {        if (b == null) {            return -1;        }        return read(b, 0, b.length);    }    public int read(byte[] b, int start, int len) throws IOException {        if (isDirectory()) {            return -1;        }        if (getInputStream() == null) {            return -1;        }        if (len - start > b.length) {            len = b.length - start;        }//        if(len>fileSize() - getOffset())//        {//            len = (int) (fileSize() - getOffset());//        }        if (len == 0) {            return 0;        }        try{            int ret = getInputStream().read(b, start, len);            if (ret >=0)                setOffset(getOffset() + ret);            return ret;        }catch(IOException ex)        {            System.out.println("we meet unexpected end of stream at " + getOffset() + " for length " + len + " filelength is " + fileSize());            ex.printStackTrace();            //unexpected end of stream            //do we need try again?            if (getOffset()<fileSize())            {                try {                    close();                    absolute(getOffset());                    int ret = getInputStream().read(b, start, len);                    if (ret >= 0) {                        setOffset(getOffset() + ret);                    }                    return ret;                } catch (IOException x) {                    System.out.println("unexpected end of stream again");                }            }            return -1;        }            }    public String getLocation() {        return location;    }    public void setLocation(String location) {        this.location = location;    }    public synchronized void reset() throws IOException {        if (getOffset() != 0) {            close();            open();        }    }    public int read() throws IOException {        int ret = getInputStream().read();        setOffset(getOffset() + 1);        return ret;    }    public void close() throws IOException {        setOffset(0);    }    public boolean copyTo(FileAccessBase dest,Object para) throws IOException    {               if (!dest.canWrite())            return false;        if (this.isFile())        {            int bugLen = 512;            if (Runtime.getRuntime().freeMemory()> 1024*1024) //have more then 1 mb free memory                bugLen = 512; //            byte []buf=new byte[bugLen];            if (dest.isDirectory())            {                dest = dest.child(this.getName());            }            if (!dest.exists())                dest.create();            long oldOffset = this.getOffset();            this.absolute(0);            int size=0;            //System.gc();            int ret = this.read(buf);            while(ret>0)            {                size+=ret;                dest.write(buf,0,ret);                ret = this.read(buf);            }            //System.out.println(this.getName() +  " wrote " + size);            this.absolute(oldOffset);            dest.flush();            dest.close();        }        else if (this.isDirectory())        {            dest = dest.mkdir(this.getName());                        Vector lists = this.listFiles();            for(int i=0; lists!=null && i<lists.size();++i)            {                FileAccessBase file = (FileAccessBase) lists.elementAt(i);                file.copyTo(dest,para);            }            dest.close();        }        return true;    }    public FileAccessBase mkdir(String string) throws IOException {        FileAccessBase file = this.child(string);        if(!file.exists())            file.mkdir();        return file;            }    public void mkdir() throws IOException{            }    public String getSeparator() {        return "/";    }    public FileAccessBase child(String dir) throws IOException {        String absolutePath = getAbsolutePath();        if (absolutePath.substring(absolutePath.length() - getSeparator().length()).equals(getSeparator())) {            return FileFactory.openFileAccess(getAbsolutePath() + dir,true);        }        return FileFactory.openFileAccess(getAbsolutePath() + getSeparator() + dir,true);    }    public abstract Vector listFiles(String name, boolean includeHidden) throws IOException;    public abstract void setInputStream(InputStream input);    public abstract void setOutputStream(OutputStream output);    public abstract void open() throws IOException ;    public abstract Vector listFiles() throws IOException ;    public abstract boolean canRead() throws IOException ;    public abstract boolean canWrite() throws IOException ;    public abstract void create() throws IOException ;        public abstract void delete() throws IOException ;    public abstract boolean exists() throws IOException;    public abstract long fileSize() ;    public abstract String getAbsolutePath() throws IOException ;    public abstract IFileFactory getFileFactory() ;    public abstract InputStream getInputStream() throws IOException;    public abstract String getName() throws IOException ;    public abstract OutputStream getOutputStream() throws IOException ;    public abstract boolean isDirectory() throws IOException;    public abstract boolean isFile() throws IOException ;    public abstract boolean isHidden() throws IOException ;        public boolean isUseTempFile()    {        return false;    }    public FileAccessBase parent() throws IOException    {        String path = getAbsolutePath();        String name = getName();        if (path.length()>name.length())            return FileFactory.openFileAccess(path.substring(0,path.length() - name.length()), true);        else            return null;    }    public void flush()  throws IOException {    }    public boolean markSupported() {	return true;    }}