/*Copyright (C) 2006,2007  Yong Li. All rights reserved.This library is free software; you can redistribute it and/ormodify it under the terms of the GNU Lesser General PublicLicense as published by the Free Software Foundation; eitherversion 2.1 of the License, or (at your option) any later version.This library is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNULesser General Public License for more details.You should have received a copy of the GNU Lesser General PublicLicense along with this library; if not, write to the Free SoftwareFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA */package com.teesoft.jfile;import com.teesoft.jfile.resource.FileObject;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.Enumeration;import java.util.Vector;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;public class zipFileAccess extends FileAccessBase {        public static class zipFileObjects extends compositeFileObjects {        File tmpDir;        zipFileObjects(String name,Object refObject) {            super(name,refObject);        }        private ZipFile tin;        public FileObject listContent(String name, Object refObj) {            File in = (File) refObj;            tmpDir = compositeFileObjects.getTempDir();            try {                tin = new ZipFile(in);                ZipEntry zipEntry;                Enumeration entries = tin.entries();                while(entries.hasMoreElements()) {                    zipEntry = (ZipEntry) entries.nextElement();                                        //System.out.println(zipEntry.getName());                    if(zipEntry.isDirectory()){                        addFolder(FileObject.split(zipEntry.getName(), '/'), getRefObject( zipEntry,tin));                    }else{                        addFile(zipEntry.getSize(), FileObject.split(zipEntry.getName(), '/'),getRefObject( zipEntry,tin));                    }                }                tin.close();            } catch (Exception ex) {                ex.printStackTrace();            }                        return getRootFile();        }                public void doClose() {            try {                InputStream in = (InputStream) getRefObject();                in.close();            } catch (IOException ex) {                ex.printStackTrace();            }                    }        public static class RefObject {            ZipEntry zipEntry;            InputStream stream;            RefObject(ZipEntry zipEntry,InputStream stream) {                this.zipEntry = zipEntry;                this.stream = stream;            }        }        public void            copyEntryContents( InputStream in,OutputStream out )            throws IOException {            byte[] buf = new byte[ 32 * 1024 ];                        for ( ; ; ) {                int numRead = in.read( buf);                if ( numRead == -1 )                    break;                out.write( buf, 0, numRead );            }        }                RefObject getRefObject(ZipEntry zipEntry, ZipFile tin) throws IOException {            if (zipEntry.isDirectory())                return new RefObject(zipEntry,null);            else if(zipEntry.getSize()<1024*1024) {                ByteArrayOutputStream out = new ByteArrayOutputStream();                copyEntryContents(tin.getInputStream(zipEntry),out);                ByteArrayInputStream in=new ByteArrayInputStream(out.toByteArray());                return new RefObject(zipEntry,in);            }            else {                File file = new File(tmpDir.getAbsolutePath() + File.separator + zipEntry.getName());                file.getParentFile().mkdirs();                file.deleteOnExit();                FileOutputStream out = new FileOutputStream(file);                copyEntryContents(tin.getInputStream(zipEntry),out);                out.close();                InputStream in = FileFactory.openFileAccess(file.getAbsolutePath(),true);                return new RefObject(zipEntry,in);                //return new RefObject(zipEntry,tin.getInputStream(zipEntry));            }        }                    }    zipFileObjects zipFile ;    protected FileObject connection;    protected InputStream input;    protected OutputStream output;        private static FileObject rootFile;    private String zipFilePath;    private String subPath;                public zipFileAccess(String s) throws IOException {        super(s);        parsePath(s);        setOffset(0);    }        public zipFileAccess(zipFileObjects zipFile,FileObject f) throws IOException {        super("zip://" + zipFile.getName() + "!/" +  f.getName());        this.zipFile = zipFile;        this.zipFilePath = zipFile.getName();        setConnection(f);        setOffset(0);    }        public void open() throws IOException {        if (connection == null) {            String s = getLocation();            //TODO            if ( zipFile == null)                zipFile = (zipFileAccess.zipFileObjects) compositeFileObjects.getCompositeFileObjectsFromCache(zipFilePath);            if (zipFile == null)                zipFile = new zipFileAccess.zipFileObjects(zipFilePath,new File(zipFilePath));                        if (zipFile!=null) {                setConnection(zipFile.getRootFile().getSubObject(this.subPath));            }        }    }        public long fileSize() {        try {            return this.getzipEntry().getSize();        } catch (IOException ex) {            return -1;        }    }        public boolean exists() throws IOException {        return getConnection()!= null&&(getConnection().isFile() || getConnection().isDirectory());    }        public boolean isDirectory() throws IOException {        return getConnection()!= null&&getConnection().isDirectory();    }        public boolean isFile() throws IOException {        return getConnection()!= null&&!getConnection().isDirectory();    }        public boolean isHidden() throws IOException {        return false;    }        public boolean canRead() throws IOException {        return exists();    }        public boolean canWrite() throws IOException {        return false;    }        public void close() throws IOException {        reset();    }        public static Vector listRoots() throws IOException {        return listRoots("");    }        public static Vector listRoots(String regex) throws IOException {        return null;    }        protected static Vector addAll(File[] arr) throws IOException {        Vector v = new Vector();        for (int i = 0; i < arr.length; i++) {            v.add(new j2seFileAccess(arr[i]));        }        return v;    }        public Vector listFiles() throws IOException {        return listFiles("*",true);    }        protected Vector addAll(Vector v, Vector newV) throws IOException {        for (int i = 0; newV !=null && i < newV.size(); i++) {            FileObject file = (FileObject) newV.elementAt(i);            v.addElement(new zipFileAccess(zipFile,file));        }        return v;    }        public Vector listFiles(String name, boolean includeHidden) throws IOException {        FileObject file = getConnection();        Vector v = new Vector();        addAll(v, file.getSubFolders());        addAll(v, file.getSubFiles());        return v;    }        protected FileObject getConnection() throws IOException {        if (connection == null) {            open();        }        if (connection == null) {            //throw new IOException("Unable to open the file:" + getLocation());        }        return connection;    }        protected void setConnection(FileObject connection) {        this.connection = connection;    }        public InputStream getInputStream() throws IOException {        if (input == null) {            input = this.getRefObject().stream;        }        return input;    }        public synchronized void reset() throws IOException {        if (getOffset() != 0) {            this.getInputStream().reset();            this.setOffset(0);        }    }    public void setInputStream(InputStream input) {        this.input = input;    }        public OutputStream getOutputStream() throws IOException {        if (output == null) {            output = null;        }        return output;    }        public void setOutputStream(OutputStream output) {        this.output = output;    }        public String getSeparator() {        return "/";    }        public String getPath() throws IOException {        return getConnection().getName();    }        public String getAbsolutePath() throws IOException {        return "zip://" + this.zipFilePath + "!" +  getConnection().getPath();    }        public String getName() throws IOException {        String name = getConnection().getName();        if (name.length() == 0) {            return name;        }        if (name.substring(name.length() - 1).equals(this.getSeparator())) {            name = name.substring(0, name.length() - 1);        }        return name;    }        public void create() throws IOException {            }            public IFileFactory getFileFactory() {        return j2seFileFactory.getInstance();    }        public void mkdir() throws IOException {            }        protected static FileAccessBase openzipFile(String fileName) throws IOException {        //System.out.println(System.getProperty("user.dir"));        if (fileName.startsWith("zip://"))            return FileFactory.openFileAccess(fileName,true);                for (int i = 0; i < FileFactory.getFactories().size(); ++i) {                        IFileFactory factory = (IFileFactory) FileFactory.getFactories().elementAt(i);            //System.out.println( factory.getClass().getName());            FileAccessBase file;            try {                if (!(factory instanceof compressedFileFactory)) {                    file = factory.newFileAccess(fileName);                                        if (file != null && (file.exists())) {                        return file;                    }                                    }            } catch (IOException ex) {                ex.printStackTrace();            }                                }                return null;    }        private zipFileObjects.RefObject getRefObject() throws IOException {        return (zipFileObjects.RefObject) this.getConnection().getRefObject();    }        private ZipEntry getzipEntry() throws IOException {        return getRefObject().zipEntry;    }        private void parsePath(String s) {        this.subPath = "";        if (s.startsWith("zip://")) {            int pos = s.indexOf("!/");            if (pos>0) {                this.zipFilePath = s.substring(6,pos);                this.subPath = s.substring(pos+2);            } else                this.zipFilePath = s.substring(6);        }else {            this.zipFilePath = s;        }    }        public boolean isUseTempFile()    {        return true;    }    @Override    public void delete() throws IOException {//        throw new UnsupportedOperationException("Not supported yet.");    }    public boolean isCompressed() {        return true;    }    public boolean isRawFile() {        return false;    }}