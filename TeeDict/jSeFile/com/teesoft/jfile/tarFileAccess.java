/*Copyright (C) 2006,2007  Yong Li. All rights reserved.This library is free software; you can redistribute it and/ormodify it under the terms of the GNU Lesser General PublicLicense as published by the Free Software Foundation; eitherversion 2.1 of the License, or (at your option) any later version.This library is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNULesser General Public License for more details.You should have received a copy of the GNU Lesser General PublicLicense along with this library; if not, write to the Free SoftwareFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA */package com.teesoft.jfile;import com.ice.tar.TarEntry;import com.ice.tar.TarInputStream;import com.teesoft.jfile.resource.FileObject;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.Vector;import java.util.zip.GZIPInputStream;import org.apache.tools.bzip2.CBZip2InputStream;public class tarFileAccess extends FileAccessBase {        public static class tarFileObjects extends compositeFileObjects {        File tmpDir;        tarFileObjects(String name,Object refObject) {            super(name,refObject);        }        private TarInputStream tin;        public FileObject listContent(String name, Object refObj) {            InputStream in = (InputStream) refObj;            tmpDir = compositeFileObjects.getTempDir();            tin = new TarInputStream(in);            try {                TarEntry tarEntry;                tarEntry = tin.getNextEntry();                while (tarEntry != null){                    //System.out.println(tarEntry.getName());                    if(tarEntry.isDirectory()){                        addFolder(FileObject.split(tarEntry.getName(), '/'), getRefObject( tarEntry,tin));                    }else{                        addFile(tarEntry.getSize(), FileObject.split(tarEntry.getName(), '/'),getRefObject( tarEntry,tin));                    }                    tarEntry = tin.getNextEntry();                }                tin.close();            } catch (IOException ex) {                ex.printStackTrace();            }                        return getRootFile();        }                public void doClose() {            try {                InputStream in = (InputStream) getRefObject();                in.close();            } catch (IOException ex) {                ex.printStackTrace();            }                    }        public static class RefObject {            TarEntry tarEntry;            InputStream stream;            RefObject(TarEntry tarEntry,InputStream stream) {                this.tarEntry = tarEntry;                this.stream = stream;            }        }        RefObject getRefObject(TarEntry tarEntry, TarInputStream tin) throws IOException {            if (tarEntry.isDirectory())                return new RefObject(tarEntry,null);            else if(tarEntry.getSize()<1024*1024) {                ByteArrayOutputStream out = new ByteArrayOutputStream();                tin.copyEntryContents(out);                ByteArrayInputStream in=new ByteArrayInputStream(out.toByteArray());                return new RefObject(tarEntry,in);            }else {                File file = new File(tmpDir.getAbsolutePath() + File.separator + tarEntry.getName());                file.getParentFile().mkdirs();                file.getParentFile().deleteOnExit();                file.deleteOnExit();                FileOutputStream out = new FileOutputStream(file);                tin.copyEntryContents(out);                out.close();                InputStream in = FileFactory.openFileAccess(file.getAbsolutePath(),true);                return new RefObject(tarEntry,in);            }        }                    }    tarFileObjects tarFile ;    protected FileObject connection;    protected InputStream input;    protected OutputStream output;        private static FileObject rootFile;    private String tarFilePath;    private String subPath;                public tarFileAccess(String s) throws IOException {        super(s);        parsePath(s);        setOffset(0);    }        public tarFileAccess(tarFileObjects tarFile,FileObject f) throws IOException {        super("tar://" + tarFile.getName() + "!/" +  f.getName());        this.tarFile = tarFile;        this.tarFilePath = tarFile.getName();        setConnection(f);        setOffset(0);    }        public void open() throws IOException {        if (connection == null) {            String s = getLocation();            //TODO            if ( tarFile == null)                tarFile = (tarFileAccess.tarFileObjects) compositeFileObjects.getCompositeFileObjectsFromCache(tarFilePath);            if (tarFile == null)                tarFile = new tarFileAccess.tarFileObjects(tarFilePath,getInputStream(tarFilePath));                        if (tarFile!=null) {                setConnection(tarFile.getRootFile().getSubObject(this.subPath));            }        }    }        public long fileSize() {        try {            return this.getTarEntry().getSize();        } catch (IOException ex) {            return -1;        }    }        public boolean exists() throws IOException {        return getConnection()!= null&&(getConnection().isFile() || getConnection().isDirectory());    }        public boolean isDirectory() throws IOException {        return getConnection()!= null&&getConnection().isDirectory();    }        public boolean isFile() throws IOException {        return getConnection()!= null&&!getConnection().isDirectory();    }        public boolean isHidden() throws IOException {        return false;    }        public boolean canRead() throws IOException {        return exists();    }        public boolean canWrite() throws IOException {        return false;    }        public void close() throws IOException {        reset();    }        public static Vector listRoots() throws IOException {        return listRoots("");    }        public static Vector listRoots(String regex) throws IOException {        return null;    }        protected static Vector addAll(File[] arr) throws IOException {        Vector v = new Vector();        for (int i = 0; i < arr.length; i++) {            v.add(new j2seFileAccess(arr[i]));        }        return v;    }        public Vector listFiles() throws IOException {        return listFiles("*",true);    }        protected Vector addAll(Vector v, Vector newV) throws IOException {        for (int i = 0; newV !=null && i < newV.size(); i++) {            FileObject file = (FileObject) newV.elementAt(i);            v.addElement(new tarFileAccess(tarFile,file));        }        return v;    }        public Vector listFiles(String name, boolean includeHidden) throws IOException {        FileObject file = getConnection();        Vector v = new Vector();        addAll(v, file.getSubFolders());        addAll(v, file.getSubFiles());        return v;    }        protected FileObject getConnection() throws IOException {        if (connection == null) {            open();        }        if (connection == null) {            //throw new IOException("Unable to open the file:" + getLocation());        }        return connection;    }        protected void setConnection(FileObject connection) {        this.connection = connection;    }        public InputStream getInputStream() throws IOException {        if (input == null) {            input = this.getRefObject().stream;        }        return input;    }        public synchronized void reset() throws IOException {        if (getOffset() != 0) {            this.getInputStream().reset();            this.setOffset(0);        }    }    public void setInputStream(InputStream input) {        this.input = input;    }        public OutputStream getOutputStream() throws IOException {        if (output == null) {            output = null;        }        return output;    }        public void setOutputStream(OutputStream output) {        this.output = output;    }        public String getSeparator() {        return "/";    }        public String getPath() throws IOException {        return getConnection().getName();    }        public String getAbsolutePath() throws IOException {        return "tar://" + this.tarFilePath + "!" +  getConnection().getPath();    }        public String getName() throws IOException {        String name = getConnection().getName();        if (name.length() == 0) {            return name;        }        if (name.substring(name.length() - 1).equals(this.getSeparator())) {            name = name.substring(0, name.length() - 1);        }        return name;    }        public void create() throws IOException {            }            public IFileFactory getFileFactory() {        return j2seFileFactory.getInstance();    }        public void mkdir() throws IOException {            }        public static InputStream getInputStream(String tarFileName) throws IOException{        String tmpName = tarFileName.toLowerCase();        if(tmpName.endsWith(".gz") || tmpName.endsWith(".z")){            //System.out.println("Creating an GZIP InputStream for the file:" + tarFileName);            return new GZIPInputStream(openTarFile(tarFileName));        }else if(tmpName.endsWith(".bz2")){            //System.out.println("Creating an BZIPInputStream for the file:" + tarFileName);            //return new CBZip2InputStream(openTarFile(tarFileName));            FileAccessBase file = openTarFile(tarFileName);            //read the "BZ" at the begin of the file            file.read();            file.read();            return new CBZip2InputStream(file);        }else{            //System.out.println("Creating an InputStream for the file:" + tarFileName);            return openTarFile(tarFileName);        }    }    protected static FileAccessBase openTarFile(String fileName) throws IOException {        //System.out.println(System.getProperty("user.dir"));        if (fileName.startsWith("tar://"))            return FileFactory.openFileAccess(fileName,true);                for (int i = 0; i < FileFactory.getFactories().size(); ++i) {                        IFileFactory factory = (IFileFactory) FileFactory.getFactories().elementAt(i);            //System.out.println( factory.getClass().getName());            FileAccessBase file;            try {                if (!(factory instanceof compressedFileFactory)) {                    file = factory.newFileAccess(fileName);                                        if (file != null && (file.exists())) {                        return file;                    }                                    }            } catch (IOException ex) {                ex.printStackTrace();            }                                }                return null;    }        private tarFileObjects.RefObject getRefObject() throws IOException {        return (tarFileObjects.RefObject) this.getConnection().getRefObject();    }        private TarEntry getTarEntry() throws IOException {        return getRefObject().tarEntry;    }        private void parsePath(String s) {        this.subPath = "";        if (s.startsWith("tar://")) {            int pos = s.indexOf("!/");            if (pos>0) {                this.tarFilePath = s.substring(6,pos);                this.subPath = s.substring(pos+2);            } else                this.tarFilePath = s.substring(6);        }else {            this.tarFilePath = s;        }    }    public boolean isUseTempFile()    {        return true;    }    @Override    public void delete() throws IOException {        //do nothing    }    public boolean isCompressed() {        return true;    }    public boolean isRawFile() {        return false;    }    }